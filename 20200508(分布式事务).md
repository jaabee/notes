[参考链接](https://mp.weixin.qq.com/s/9KKY3pCKNkz1VOVEzdXp5g) [链接](https://www.cnblogs.com/mayundalao/p/11798502.html)
#### 分布式事务的五种方案
##### 1. 两阶段提交方案/XA方案 
引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务
1. 准备阶段,协调者询问参与者事务是否执行成功，参与者发回事务执行结果。
2. 提交阶段,如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。
3. 存在问题。1.同步阻塞，所有参与者都要等待 2.协调者单点问题 3.如果协调者数据不及时，数据可能不一致 4.没有容错机制
##### 2. TCC方案 <br>
TCC 的全称是：Try、Confirm、Cancel。
1. Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。
2. Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。
3. Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）
举个例子，假入 Bob 要向 Smith 转账，思路大概是： 我们有一个本地方法，里面依次调用
    首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。
    在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。
    如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。
##### 3. 本地消息表（最终一致性方案）<br>
1. A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；
2. 接着 A 系统将这个消息发送到 MQ 中去；
3. B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；
4. 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；
5. 果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；
6. 这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。但是严重依赖数据库，不适合高并发场景
##### 4. 可靠消息最终一致性方案 <br>
不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。
1.系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；
2. 如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；
3. 如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；
4. mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你5. 这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿
##### 5. 最大努力通知方案（和3一样？） <br>
1. 系统 A 本地事务执行完之后，发送个消息到 MQ；
2. 这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；
3. 要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃
	
	
	
