[链接](https://github.com/jaabee/design-patterns) 
创建型：单例、抽象工厂、建造者、工厂、原型 
结构性：适配器、桥接、装饰、组合、外观、享元、代理 
行为型：模版方法、命令、迭代器、观察者、中介者、备忘录、解释器、状态、策略、职责链、访问者 

> 设计模式的宗旨是重用，目的是建立对象之间的关联，提供让代码间松耦合的方案
> 有两个原则，1.按接口编程而不是按实现来编程。2.优先使用组合而不是继承


#### 单例模式
应用场景：
> 数据库连接等比较耗时的操作
结构：
> 4私1公
> 私有化构造方法：防止通过new实例化
> 私有化反序列化方法：防止反序列化
> 私有化clone方法：防止clone多个示例
示例
```
class Singleton
{
	private static $instance = null;
	public static function getInstance()
	{
		if(static::$instance === null){
			static::$instance = new static();
		}
		return static::$instance;
	}
	private function __construct(){}
	private function __clone(){}
	private function __wakeup(){}
}
```

#### 简单工厂模式
应用场景
> 不确定有多少种操作
结构
> 根据不同的操作调用不同的类
> 只需实例化工厂类，工厂类会根据操作不同，实例化对应的操作类
弊端
> 如果要增加操作需要更改工厂类，违反了opp的开放封闭原则（对扩展开放，对修改封闭），理想条件是增加操作，只需要增加新的扩展

#### 工厂模式
应用场景
> 要创建的类型和数目未知
结构
> 一个产品类，多个产品子类(ABC)
> 一个工厂类，多个工厂子类(abc)，abc分别实例化ABC
> 增加类型时，增加工厂子类d，增加产品子类D，工厂子类d中实例化产品子类D
> 使用时只需要实例化对应的工厂子类

#### 抽象工厂模式
应用场景
> 同上
结构
> 同上
> 增加类型时，不增加子类，而是在对应子类里增加方法

优化
> 1. 可以根据反射优化简单工厂模式

#### 原型模式
应用场景
> 创建重复对象
> 使用clone减少new对象的开销
结构
> clone
> php默认的clone时浅复制，复制的是一个引用，原对象改变，clone的对象也会改变，可以在__clone方法里改变变量的引用
> $this->car = clone $this->car

#### 建造者模式
应用场景
> 防止函数的参数过多和不易读，注入一个构建器，DIV参数，加强易读性












